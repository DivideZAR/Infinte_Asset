<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Episode 1: The Influx</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
      const { useState, useEffect, useRef, useMemo } = React;
    </script>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      html, body, #root { width: 100%; height: 100%; overflow: hidden; background: #1a1a2e; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const TOTAL_DURATION = 30;
      const CUBE_COUNT = 800;
      const HIGHWAY_Y_MIN = 0.3;
      const HIGHWAY_Y_MAX = 0.7;
      const DOOR_SPLIT = 0.5;
      
      const srandom = (seed) => {
        let x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
      };
      
      class Cube {
        constructor(id) {
          this.id = id;
          this.reset();
          this.depth = srandom(id) * 0.5 + 0.5;
          this.yOffset = srandom(id + 1);
          this.speedBase = srandom(id + 2) * 2 + 1;
          this.hue = 45 + srandom(id + 3) * 10;
        }
        
        reset() {
          this.x = -100 - srandom(this.id * 10) * 200;
          this.active = false;
          this.jammed = false;
        }
      }
      
      function App() {
        const canvasRef = useRef(null);
        const requestRef = useRef(null);
        const startTimeRef = useRef(null);
        const [isPlaying, setIsPlaying] = useState(true);
        const [currentTime, setCurrentTime] = useState(0);
        const [isFinished, setIsFinished] = useState(false);
        const [alarmActive, setAlarmActive] = useState(false);
        const [voVisible, setVoVisible] = useState(false);
        
        const cubes = useMemo(() => {
          const arr = [];
          for (let i = 0; i < CUBE_COUNT; i++) {
            arr.push(new Cube(i));
          }
          return arr;
        }, []);
        
        const togglePlay = () => {
          if (isFinished) {
            handleRestart();
          } else {
            setIsPlaying(!isPlaying);
          }
        };
        
        const handleRestart = () => {
          setIsPlaying(true);
          setCurrentTime(0);
          setIsFinished(false);
          startTimeRef.current = performance.now();
          cubes.forEach(c => c.reset());
        };
        
        const animate = (time) => {
          if (!isPlaying) {
            startTimeRef.current = null;
            return;
          }
          
          if (startTimeRef.current === null) {
            startTimeRef.current = time - (currentTime * 1000);
          }
          
          const elapsed = (time - startTimeRef.current) / 1000;
          
          if (elapsed >= TOTAL_DURATION) {
            setCurrentTime(TOTAL_DURATION);
            setIsFinished(true);
            setIsPlaying(false);
            draw(TOTAL_DURATION);
            return;
          }
          
          setCurrentTime(elapsed);
          draw(elapsed);
          requestRef.current = requestAnimationFrame(animate);
        };
        
        useEffect(() => {
          if (isPlaying) {
            requestRef.current = requestAnimationFrame(animate);
          } else {
            cancelAnimationFrame(requestRef.current);
          }
          return () => cancelAnimationFrame(requestRef.current);
        }, [isPlaying]);
        
        const draw = (t) => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          const w = canvas.width;
          const h = canvas.height;
          
          ctx.clearRect(0, 0, w, h);
          
          const doorProgress = Math.min(Math.max((t - 3.0) / 3.0, 0), 1);
          const shakeIntensity = t < 10 ? (t < 3 ? 0.5 : 1.0) : (t > 20 ? (t - 20) * 0.2 : 0.1);
          const isAlarm = t < 10 && Math.floor(t * 4) % 2 === 0;
          
          ctx.save();
          if (isPlaying) {
            const dx = (Math.random() - 0.5) * shakeIntensity * 2;
            const dy = (Math.random() - 0.5) * shakeIntensity * 2;
            ctx.translate(dx, dy);
          }
          
          const bgGradient = ctx.createLinearGradient(0, 0, w, 0);
          bgGradient.addColorStop(0, '#0f0f15');
          bgGradient.addColorStop(0.4, '#1a0505');
          bgGradient.addColorStop(1, '#3a0000');
          ctx.fillStyle = bgGradient;
          ctx.fillRect(0, 0, w, h);
          
          const highwayH = h * (HIGHWAY_Y_MAX - HIGHWAY_Y_MIN);
          const highwayY = h * HIGHWAY_Y_MIN;
          
          ctx.fillStyle = 'rgba(50, 0, 0, 0.5)';
          ctx.fillRect(0, highwayY, w, highwayH);
          
          ctx.strokeStyle = 'rgba(255, 50, 50, 0.2)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let ix = 0; ix < w; ix += 50) {
            ctx.moveTo(ix - (t * 100) % 50, highwayY);
            ctx.lineTo(ix - (t * 100) % 50 + 100, highwayY + highwayH);
          }
          const speedPixels = 200;
          const offset = (t * speedPixels) % 100;
          for (let lx = -offset; lx < w; lx += 100) {
            ctx.moveTo(lx, highwayY);
            ctx.lineTo(lx, highwayY + highwayH);
          }
          ctx.stroke();
          
          const influxStart = 3.5;
          
          ctx.shadowBlur = 10;
          ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
          
          cubes.forEach((cube, i) => {
            if (!cube.active && t > influxStart) {
              if (i < (t - influxStart) * 50) {
                cube.active = true;
                cube.x = w * 0.1;
              }
            }
            
            if (cube.active) {
              let speed = cube.speedBase * 3 * (w / 1920);
              
              if (cube.x > w * 0.5) {
                const jamSeverity = Math.max(0, (t - 15) / 10);
                speed *= Math.max(0.1, 1 - jamSeverity);
              }
              
              if (isPlaying) {
                cube.x += speed;
              }
              
              const size = 10 * cube.depth;
              const cy = highwayY + (cube.yOffset * (highwayH - size));
              
              ctx.fillStyle = `hsl(${cube.hue}, 100%, 50%)`;
              ctx.globalAlpha = cube.depth;
              ctx.fillRect(cube.x, cy, size, size);
              ctx.globalAlpha = 1.0;
            }
          });
          ctx.shadowBlur = 0;
          
          const doorW = w * 0.5;
          const openAmount = doorProgress * (doorW - (w * 0.1));
          
          const leftDoorX = -openAmount;
          ctx.fillStyle = '#111';
          ctx.fillRect(leftDoorX, 0, doorW, h);
          ctx.fillStyle = '#222';
          ctx.fillRect(leftDoorX + doorW - 20, 0, 20, h);
          ctx.fillStyle = isAlarm ? '#ff0000' : '#500';
          ctx.fillRect(leftDoorX + doorW - 10, h/2 - 50, 5, 100);
          
          const rightDoorX = w * 0.5 + openAmount;
          ctx.fillStyle = '#111';
          ctx.fillRect(rightDoorX, 0, doorW, h);
          ctx.fillStyle = '#222';
          ctx.fillRect(rightDoorX, 0, 20, h);
          ctx.fillStyle = isAlarm ? '#ff0000' : '#500';
          ctx.fillRect(rightDoorX + 5, h/2 - 50, 5, 100);
          
          if (t > 5) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const crackProgress = Math.max(0, (t - 10) / 20);
            if (crackProgress > 0) {
              const startX = w * 0.2;
              ctx.moveTo(startX, highwayY);
              let cx = startX;
              let cy = highwayY;
              for (let k = 0; k < crackProgress * 50; k++) {
                cx += 20;
                cy = highwayY + (Math.random() - 0.5) * 30;
                ctx.lineTo(cx, cy);
              }
            }
            if (crackProgress > 0) {
              const startX = w * 0.3;
              ctx.moveTo(startX, highwayY + highwayH);
              let cx = startX;
              let cy = highwayY + highwayH;
              for (let k = 0; k < crackProgress * 60; k++) {
                cx += 15;
                cy = highwayY + highwayH + (Math.random() - 0.5) * 30;
                ctx.lineTo(cx, cy);
              }
            }
            ctx.stroke();
          }
          
          if (t < 10) {
            ctx.save();
            ctx.globalAlpha = Math.max(0, 1 - t/10) * (Math.sin(t * 10) * 0.5 + 0.5);
            ctx.fillStyle = 'red';
            ctx.fillRect(0, 0, w, h);
            ctx.restore();
          }
          
          ctx.restore();
        };
        
        useEffect(() => {
          const handleResize = () => {
            if (canvasRef.current) {
              const parent = canvasRef.current.parentElement;
              canvasRef.current.width = parent.clientWidth * window.devicePixelRatio;
              canvasRef.current.height = parent.clientHeight * window.devicePixelRatio;
              draw(currentTime);
            }
          };
          window.addEventListener('resize', handleResize);
          handleResize();
          return () => window.removeEventListener('resize', handleResize);
        }, [currentTime]);
        
        useEffect(() => {
          setAlarmActive(currentTime < 10);
          setVoVisible(currentTime > 8 && currentTime < 18);
        }, [currentTime]);
        
        const formatTime = (t) => {
          const s = Math.floor(t);
          return "0:" + s.toString().padStart(2, '0');
        };
        
        const subtitleText = "The system is flooded. Pressure is critical.";
        
        return React.createElement('div', {
          className: 'relative w-full h-screen bg-black overflow-hidden font-mono text-white select-none'
        }, 
          React.createElement('div', { className: 'absolute inset-0 z-0' },
            React.createElement('canvas', {
              ref: canvasRef,
              className: 'w-full h-full block',
              style: { width: '100%', height: '100%' }
            })
          ),
          React.createElement('div', { className: 'absolute inset-0 z-10 pointer-events-none flex flex-col justify-between p-6' },
            React.createElement('div', { className: 'flex justify-between items-start' },
              React.createElement('div', { className: 'bg-black/50 p-2 border border-red-500/30 backdrop-blur-sm rounded' },
                React.createElement('div', { className: 'text-xs text-red-400' }, 'SECTOR'),
                React.createElement('div', { className: 'text-lg font-bold' }, 'STOMACH // BLOODSTREAM')
              ),
              React.createElement('div', {
                className: "transition-opacity duration-200 " + (alarmActive ? 'opacity-100' : 'opacity-0')
              },
                React.createElement('div', { className: 'bg-red-600/90 text-white px-6 py-2 rounded animate-pulse shadow-[0_0_20px_rgba(220,38,38,0.6)]' },
                  React.createElement('h1', { className: 'text-2xl font-black tracking-widest' }, 'INCOMING CARGO')
                )
              ),
              React.createElement('div', { className: 'bg-black/50 p-2 border border-blue-500/30 backdrop-blur-sm rounded text-right' },
                React.createElement('div', { className: 'text-xs text-blue-400' }, 'PRESSURE'),
                React.createElement('div', { className: 'text-lg font-bold text-blue-200' },
                  Math.min(100 + currentTime * 5, 250).toFixed(0) + ' PSI'
                )
              )
            ),
            React.createElement('div', { className: 'flex-1 flex items-end justify-center pb-20' },
              React.createElement('div', {
                className: "transition-all duration-1000 transform " + (voVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4')
              },
                React.createElement('div', { className: 'bg-black/80 px-6 py-4 rounded-lg border-l-4 border-yellow-500 max-w-2xl text-center backdrop-blur-md' },
                  React.createElement('p', { className: 'text-xl md:text-2xl font-semibold text-yellow-50 shadow-black drop-shadow-md' },
                    subtitleText
                  )
                )
              )
            )
          )
        );
      }
      
      window.animationReady = true;
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    </script>
  </body>
</html>